# Put HAL commands in this file that you want to run before the GUI loads

# Pause sequence
#   Stop G code execution immediates
#   Can resume program after last finished command
#   stop spindle
#   raise Z to max height
#   go back to home

# Unpause sequence
#   move Z above xy location of start of next program line
#   start spindle
#   wait for spindle to be at speed
#   move Z down to programmed location
#   resume program

# Software estop sequence - consider all possible scenarios
#   stop axis movements
#   activate z brake
#   stop spindle if spinning
#   stop any tool change in progress and reset to proper state
#   what to do during probing
#   how does the choosen gui connect to physical estop button
#   For more information on an external E-Stop see the estop_latch man page.
#   • halui.estop.activate (bit, in) - pin for requesting E-Stop
#   • halui.estop.is-activated (bit, out) - indicates E-stop reset
#   • halui.estop.reset (bit, in) - pin for requesting E-Stop reset
#   Go thru all servo and vfd manuals to look for specific estop instructions
#   GCode macros to deal with estop situations

# Physical estop sequence - if software or computer fails
#   physical button also connects to software estop
#   Use a Safety PLC or NC relay(s) as the estop mechanism, use flyback diodes for inductive loads
#   Independent system from linuxCNC software
#   wire NC circuits in series with the "normal" linuxCNC controlled switches/relays
#   button cuts servo enable signal
#   button cuts Z brake release signal
#   button stops spindle - trigger VFD STO (Safe Torque Off). See VFD manual
#   Safety PLC can allow for more complicated logic, simple relays will work for simple control

# Start sequence
#   Servo Enable, tie all enable to one output
#   VFD enable
#   Release Z brake, upon reception of HLFB
#   others...


# When LinuxCNC starts, 
# signal estop-loopback = false when estop condition exist, goes true when user releases estop in the UI
# halui.machine.on goes true when user presses Power-on in the UI


# Default config from MesaCT
## E-Stop Chain
#loadrt estop_latch count=1
#addf estop-latch.0 servo-thread
#
## E-Stop Loop
#net estop-loopin iocontrol.0.user-enable-out => estop-latch.0.ok-in
#net estop-loopout estop-latch.0.ok-out => iocontrol.0.emc-enable-in
#
## E-Stop Reset
#net estop-reset <= iocontrol.0.user-request-enable
#net estop-reset => estop-latch.0.reset
#net remote-estop0 estop-latch.0.fault-in <= hm2_[MESA](BOARD).0.inmux.00.input-00